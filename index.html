<!doctype html>
<meta charset="utf-8">
<title>ESP32 Dual-Region Flasher</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;max-width:720px;margin:24px auto}
  .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin:10px 0}
  button{padding:8px 12px;border:1px solid #ccc;border-radius:8px;background:#f6f6f6;cursor:pointer}
  button:disabled{opacity:.5;cursor:not-allowed}
  progress{width:260px;height:14px}
  pre{background:#0c0f14;color:#e6e6e6;padding:12px;border-radius:8px;height:220px;overflow:auto;font-family:ui-monospace}
</style>

<h1>ESP32 Dual-Region Flasher</h1>
<p>This writes your selected <code>.bin</code> to <b>0x20000</b> and <b>0x1C0000</b>. Offsets are locked.</p>

<div class="row">
  <input type="file" id="fw" accept=".bin">
  <label>Baud
    <select id="baud"><option>921600</option><option>460800</option><option selected>115200</option></select>
  </label>
</div>

<div class="row">
  <button id="connect">Connect</button>
  <button id="flash" disabled>Flash (0x20000 & 0x1C0000)</button>
  <button id="disconnect" disabled>Disconnect</button>
  <span id="status">Not connected</span>
</div>

<div class="row">
  <progress id="prog" max="100" value="0"></progress>
  <span id="pct">0%</span>
</div>

<pre id="log">Loading flasher…</pre>

<script>
(async () => {
  const $ = id => document.getElementById(id);
  const logEl = $('log');
  const log = s => { logEl.textContent += (logEl.textContent ? "\n" : "") + s; logEl.scrollTop = logEl.scrollHeight; };

  // Load esptool-js from CDN (unpkg -> jsDelivr). If both fail, instruct to host locally.
  async function load(url){ return new Promise((res,rej)=>{ const s=document.createElement('script'); s.src=url; s.onload=res; s.onerror=()=>rej(new Error(url)); document.head.appendChild(s); }); }
  try { await load("https://unpkg.com/esptool-js@0.5.6/bundle.js"); }
  catch { try { log("unpkg blocked, trying jsDelivr…"); await load("https://cdn.jsdelivr.net/npm/esptool-js@0.5.6/bundle.js"); }
          catch { log("ERROR: Could not load esptool-js. Host a local copy named esptooljs.bundle.js and add:");
                 log('<script src="./esptooljs.bundle.js"></script>'); return; } }

  if (!window.ESPLoader) { log("ERROR: esptool-js loaded but ESPLoader global missing."); return; }
  const TransportCtor = window.TransportWebSerial || window.WebSerialTransport || window.Transport;
  if (!TransportCtor) { log("ERROR: WebSerial transport class missing in this bundle."); return; }
  log("Flasher ready.");

  const OFFSETS = [0x20000, 0x1C0000];
  const term = { write: s => log(s), writeLine: s => log(s), clean: () => { logEl.textContent = ""; } };
  let transport = null, loader = null;

  function setConnected(yes){
    $('disconnect').disabled = !yes;
    $('flash').disabled = !yes || !$('fw').files[0];
    $('connect').disabled = yes;
    $('status').textContent = yes ? "Connected" : "Not connected";
  }
  $('fw').onchange = () => { $('flash').disabled = !(transport && $('fw').files[0]); };

  $('connect').onclick = async () => {
    try {
      if (!('serial' in navigator)) throw new Error('Web Serial not supported (use Chrome/Edge over HTTPS).');
      const port = await navigator.serial.requestPort({});
      const baud = parseInt($('baud').value, 10);
      transport = (TransportCtor.length >= 1) ? new TransportCtor(port) : new TransportCtor();
      if (typeof transport.connect === 'function') await transport.connect(baud);
      loader = new ESPLoader({ transport, baudrate: baud, terminal: term });
      term.clean(); log("Connecting…");
      if (loader.initialize) await loader.initialize(); else { await loader.connect?.(); await loader.sync?.(); await loader.flush?.(); }
      setConnected(true);
      if (loader.chipName) log("Chip: " + await loader.chipName());
    } catch (e) {
      log("Connect error: " + (e?.message || e));
      try { await transport?.disconnect?.(); } catch {}
      transport = loader = null; setConnected(false);
    }
  };

  $('disconnect').onclick = async () => { try { await transport?.disconnect?.(); } catch {} transport=loader=null; setConnected(false); };

  function updatePct(p){ $('prog').value = p; $('pct').textContent = (Number.isFinite(p) ? p.toFixed(1) : p) + "%"; }

  $('flash').onclick = async () => {
    try {
      const f = $('fw').files[0];
      if (!f) { alert("Pick a .bin first."); return; }
      const data = new Uint8Array(await f.arrayBuffer());
      log(`Flashing ${f.name} (${data.length} bytes) to 0x20000 and 0x1C0000…`);
      updatePct(0);

      const jobs = OFFSETS.map(addr => ({ data, address: addr }));

      if (typeof loader.flash === 'function') {
        await loader.flash(jobs, p => { if (Number.isFinite(p)) updatePct(p); });
      } else if (typeof loader.flashIdfData === 'function') {
        await loader.flashIdfData(jobs, p => { if (Number.isFinite(p)) updatePct(p); });
      } else if (typeof loader.writeFlash === 'function') {
        const fileArray = jobs.map(j => ({ address: j.address, data: loader.ui8ToBstr(j.data) }));
        await loader.writeFlash({
          fileArray, flashSize: "keep", flashMode: "keep", flashFreq: "keep", eraseAll: false, compress: true,
          reportProgress: (_, w, t) => { const p = t ? (w / t) * 100 : 0; updatePct(p); }
        });
      } else {
        throw new Error("No compatible flash method in bundle.");
      }

      log("Done. Resetting…");
      await loader.hardReset?.();
      log("Complete.");
    } catch (e) {
      log("Flash error: " + (e?.message || e));
    }
  };
})();
</script>


