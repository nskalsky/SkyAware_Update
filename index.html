<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>ESP32 Web Flasher (factory + ota_1)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;max-width:860px;margin:24px auto}
    fieldset{border:1px solid #ddd;border-radius:12px;padding:16px;margin:16px 0}
    legend{padding:0 8px;font-weight:700}
    .row{display:flex;gap:16px;align-items:center;flex-wrap:wrap}
    .btn{padding:10px 14px;border-radius:10px;border:1px solid #ccc;background:#f6f6f6;cursor:pointer}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    input[type="text"]{width:140px}
    #log{background:#0c0f14;color:#e6e6e6;padding:12px;height:260px;overflow:auto;border-radius:8px;font-family:ui-monospace, SFMono-Regular, Menlo, monospace}
    .hint{color:#666;font-size:.95em}
    progress{width:260px;height:14px}
    label{display:block;margin:8px 0 4px}
  </style>
</head>
<body>
  <h1>ESP32 Web Flasher</h1>
  <p class="hint">Chrome/Edge only. GitHub Pages is HTTPS, so Web Serial works. Select port → choose bins → Flash.</p>

  <div class="row">
    <label>Baud
      <select id="baud">
        <option>921600</option>
        <option>460800</option>
        <option selected>115200</option>
      </select>
    </label>
    <button id="connect" class="btn">Connect</button>
    <button id="disconnect" class="btn" disabled>Disconnect</button>
    <button id="chipInfo" class="btn" disabled>Chip Info</button>
    <button id="erase" class="btn" disabled>Erase Flash</button>
    <span id="status">Not connected</span>
  </div>

  <fieldset>
    <legend>Images</legend>
    <div class="row">
      <div>
        <label>factory.bin</label>
        <input type="file" id="factory" accept=".bin" />
      </div>
      <div>
        <label>Address (hex)</label>
        <input type="text" id="addrFactory" value="0x10000" />
      </div>
    </div>
    <div class="row">
      <div>
        <label>ota_1.bin</label>
        <input type="file" id="ota1" accept=".bin" />
      </div>
      <div>
        <label>Address (hex)</label>
        <input type="text" id="addrOta1" value="0x210000" />
      </div>
    </div>
    <p class="hint">Use your real partition layout (e.g., app @ <code>0x10000</code>; OTA slots per your CSV).</p>
    <div class="row">
      <button id="flash" class="btn" disabled>Flash</button>
      <progress id="prog" max="100" value="0"></progress>
      <span id="pct">0%</span>
    </div>
  </fieldset>

  <h3>Log</h3>
  <pre id="log"></pre>

  <!-- Load LOCAL bundle to avoid CDN/CSP issues -->
  <script src="./esptooljs.bundle.js"></script>
  <script>
    const $ = (id)=>document.getElementById(id);
    const logEl = $("log"), statusEl = $("status");
    const term = { clean(){logEl.textContent=""}, write(s){logEl.textContent+=s;logEl.scrollTop=logEl.scrollHeight}, writeLine(s){term.write(s+"\n")} };
    const ui = { connect:$("connect"), disconnect:$("disconnect"), flash:$("flash"), erase:$("erase"), info:$("chipInfo"),
                 baud:$("baud"), prog:$("prog"), pct:$("pct"), factory:$("factory"), ota1:$("ota1"),
                 addrFactory:$("addrFactory"), addrOta1:$("addrOta1") };

    function getTransportCtor(){ return window.TransportWebSerial || window.WebSerialTransport || window.Transport || null; }
    function has(o,m){ return o && typeof o[m]==="function"; }
    function parseHex(s){ const v=s.trim().toLowerCase(); if(!/^0x[0-9a-f]+$/.test(v)) throw new Error("Bad hex: "+s); return parseInt(v,16); }
    async function fileToU8(inp){ if(!inp.files?.[0]) return null; return new Uint8Array(await inp.files[0].arrayBuffer()); }

    let transport=null, loader=null;
    function setConnected(yes){ ui.disconnect.disabled=!yes; ui.flash.disabled=!yes; ui.erase.disabled=!yes; ui.info.disabled=!yes; ui.connect.disabled=yes; statusEl.textContent=yes?"Connected":"Not connected"; }
    async function initLoader(l){ if(has(l,"initialize")) return l.initialize(); if(has(l,"connect")) await l.connect(); if(has(l,"sync")) await l.sync(); if(has(l,"flush")) await l.flush(); }

    ui.connect.onclick = async () => {
      try{
        if(!window.ESPLoader) throw new Error("ESPLoader missing (bundle didn’t load)");
        const T = getTransportCtor(); if(!T) throw new Error("WebSerial transport class missing");
        if(!("serial" in navigator)) throw new Error("Web Serial not supported (use Chrome/Edge)");
        const port = await navigator.serial.requestPort({filters:[]});
        transport = (T.length>=1) ? new T(port) : new T();
        if(has(transport,"connect")) await transport.connect(parseInt(ui.baud.value,10));
        loader = new ESPLoader({ transport, baudrate: parseInt(ui.baud.value,10), terminal: term });
        term.clean(); term.writeLine("Connecting…");
        await initLoader(loader);
        setConnected(true);
        if(has(loader,"chipName")) term.writeLine("Chip: " + await loader.chipName());
      }catch(e){
        term.writeLine("Connect error: " + (e && e.message ? e.message : e));
        try{ if(transport?.disconnect) await transport.disconnect(); }catch{}
        transport=null; loader=null; setConnected(false);
      }
    };

    ui.disconnect.onclick = async () => { try{ if(transport?.disconnect) await transport.disconnect(); }catch{} transport=null; loader=null; setConnected(false); };

    ui.info.onclick = async () => {
      try{
        const n = has(loader,"chipName") ? await loader.chipName() : "(unknown)";
        const m = has(loader,"readMac") ? await loader.readMac() : "(unavailable)";
        term.writeLine("Chip: "+n); term.writeLine("MAC:  "+m);
      }catch(e){ term.writeLine("Chip info error: " + e.message); }
    };

    ui.erase.onclick = async () => {
      try{
        term.writeLine("Erasing flash…");
        if(!has(loader,"eraseFlash")) throw new Error("eraseFlash not supported in this bundle");
        await loader.eraseFlash(); term.writeLine("Erase completed.");
      }catch(e){ term.writeLine("Erase error: " + e.message); }
    };

    ui.flash.onclick = async () => {
      ui.prog.value=0; ui.pct.textContent="0%";
      try{
        const fApp = await fileToU8(ui.factory);
        const oApp = await fileToU8(ui.ota1);
        if(!fApp && !oApp) { alert("Select at least one .bin"); return; }

        const jobs = [];
        if (fApp) jobs.push({ data:fApp, address: parseHex(ui.addrFactory.value) });
        if (oApp) jobs.push({ data:oApp, address: parseHex(ui.addrOta1.value) });

        term.writeLine("Flashing…");
        if (has(loader,"flash")) {
          await loader.flash(jobs, (pct)=>{ if(Number.isFinite(pct)){ ui.prog.value=pct; ui.pct.textContent=pct.toFixed(1)+"%"; } });
        } else if (has(loader,"flashIdfData")) {
          await loader.flashIdfData(jobs, (pct)=>{ if(Number.isFinite(pct)){ ui.prog.value=pct; ui.pct.textContent=pct.toFixed(1)+"%"; } });
        } else if (has(loader,"writeFlash")) {
          const fileArray = jobs.map(j=>({ address:j.address, data: loader.ui8ToBstr(j.data) }));
          await loader.writeFlash({
            fileArray, flashSize:"keep", flashMode:"keep", flashFreq:"keep", eraseAll:false, compress:true,
            reportProgress: (_,w,t)=>{ const pct=t? (w/t)*100:0; ui.prog.value=pct; ui.pct.textContent=pct.toFixed(1)+"%"; }
          });
        } else { throw new Error("No compatible flash method in this bundle"); }

        term.writeLine("Done. Resetting…");
        if (has(loader,"hardReset")) await loader.hardReset();
        if (has(loader,"after")) await loader.after("hard_reset");
        term.writeLine("Complete.");
      }catch(e){ term.writeLine("Flash error: " + e.message); }
    };

    const enableFlashIfReady = () => { $("flash").disabled = !(transport && (ui.factory.files[0] || ui.ota1.files[0])); };
    ui.factory.onchange = enableFlashIfReady; ui.ota1.onchange = enableFlashIfReady;
  </script>
</body>
</html>

