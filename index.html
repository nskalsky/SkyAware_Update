<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>ESP Flasher (Factory + OTA_1)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:20px}
    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin-bottom:10px}
    button{padding:8px 12px}
    #log{white-space:pre-wrap;background:#111;color:#0f0;padding:10px;border-radius:6px;min-height:200px;max-height:50vh;overflow:auto}
    #progress{width:320px;height:12px;background:#eee;border-radius:6px;overflow:hidden}
    #bar{height:100%;width:0%;background:#3b82f6;transition:width .1s}
    #pct{min-width:40px;display:inline-block}
  </style>
</head>
<body>
  <h1>ESP Flasher (Factory + OTA_1)</h1>

  <div class="row">
    <button id="connect">🔌 Connect</button>
    <button id="disconnect" disabled>🔒 Disconnect</button>
    <input type="file" id="fw" accept=".bin" />
    <button id="flash" disabled>⚡ Flash both</button>
  </div>

  <div class="row">
    <div id="progress"><div id="bar"></div></div>
    <span id="pct">0%</span>
  </div>

  <pre id="log"></pre>

  <script type="module">
    // ===== UI helpers =====
    const $ = s => document.querySelector(s);
    const connectBtn = $('#connect'), disconnectBtn = $('#disconnect'), flashBtn = $('#flash'), fwInput = $('#fw');
    const logEl = $('#log'), bar = $('#bar'), pct = $('#pct');
    const log = (m="") => { logEl.textContent += m + "\n"; logEl.scrollTop = logEl.scrollHeight; };
    const setProgress = n => { const v = Math.max(0, Math.min(100, n|0)); bar.style.width = v + '%'; pct.textContent = v + '%'; };

    log(`page loaded. secure=${window.isSecureContext} webSerial=${'serial' in navigator}`);

    // ===== Dynamic loader: try ESM, then UMD fallback =====
    let ESPLoaderCtor = null, TransportCtor = null;

    async function loadEsptool() {
      try {
        const esm = await import('https://esm.sh/esptool-js@0.5.7');
        const web = await import('https://esm.sh/esptool-js@0.5.7/webserial.js');
        if (esm?.ESPLoader && web?.Transport) {
          ESPLoaderCtor = esm.ESPLoader;
          TransportCtor = web.Transport;
          log('✅ esptool-js (ESM) loaded.');
          return;
        }
        throw new Error('ESM exports missing');
      } catch (e) {
        log('ℹ️ ESM import failed; trying UMD fallback… (' + e + ')');
      }
      // UMD fallback
      await new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = 'https://unpkg.com/esptool-js@0.5.7/bundle.js';
        s.onload = resolve;
        s.onerror = () => reject(new Error('Failed to load UMD bundle.js'));
        document.head.appendChild(s);
      });
      // UMD exposes a global; detect it
      const g = window;
      const ESPL =
        g.ESPLoader ||
        (g.esptoolJs && g.esptoolJs.ESPLoader) ||
        (g.esptool_js && g.esptool_js.ESPLoader) ||
        (g.esptooljs && g.esptooljs.ESPLoader);
      // for UMD, Transport is attached at ESPL.Transport
      if (ESPL && ESPL.Transport) {
        ESPLoaderCtor = ESPL;
        TransportCtor = ESPL.Transport;
        log('✅ esptool-js (UMD) loaded.');
        return;
      }
      throw new Error('UMD loaded but ESPLoader/Transport not found');
    }

    // ===== State =====
    let port = null, transport = null, loader = null;
    let connected = false, connecting = false;

    // ESPLoader terminal interface
    const term = { clean(){ logEl.textContent=""; }, write(d){ log(String(d)); }, writeLine(d){ log(String(d)); } };

    // Open only if needed; reuse if already open
    async function openPortIfNeeded(p){
      if (p.readable && p.writable) { log('port already open (reusing)'); return; }
      await p.open({ baudRate: 115200 });
      log('port opened');
    }

    async function safeCloseAll(reason=''){
      try { if (loader) await loader.after('no_reset'); } catch {}
      try { if (transport?.disconnect) await transport.disconnect(); } catch {}
      try { if (port?.readable || port?.writable) await port.close(); } catch {}
      loader=null; transport=null; connected=false; connecting=false;
      disconnectBtn.disabled = true; flashBtn.disabled = true;
      if (reason) log('closed: ' + reason);
    }

    async function withStubBaud(baud=921600){
      await loader.runStub();
      try { await loader.changeBaud(baud); log('baud -> ' + baud); } catch(e){ log('baud change failed: ' + e); }
    }

    async function flashOnce(bytes, offset, onBlock){
      const total = bytes.length;
      const blockSize = loader.FLASH_WRITE_SIZE || 0x400;
      const blocks = await loader.flashDeflBegin(total, total, offset);
      for (let i=0;i<blocks;i++){
        const s=i*blockSize, e=Math.min(s+blockSize,total);
        await loader.flashDeflBlock(bytes.subarray(s,e), i, 5000);
        onBlock?.(i+1, blocks);
      }
      await loader.flashDeflFinish(false);
    }

    async function verifyMd5(off,len){ const md5=await loader.flashMd5sum(off,len); log(`MD5 @ 0x${off.toString(16)} = ${md5}`); }

    // ===== Boot =====
    if (!window.isSecureContext) log('❌ Needs HTTPS (GitHub Pages is fine).');
    if (!('serial' in navigator)) log('❌ Web Serial not available (Chrome/Edge desktop).');

    try { await loadEsptool(); } catch (e) { log('❌ Failed to load esptool-js: ' + e); }

    connectBtn.addEventListener('click', async () => {
      if (connecting || connected) { log('already connecting/connected'); return; }
      if (!ESPLoaderCtor || !TransportCtor) { log('❌ esptool-js not loaded'); return; }
      if (!window.isSecureContext || !('serial' in navigator)) return;
      connecting = true; connectBtn.disabled = true;

      try {
        const granted = await navigator.serial.getPorts();
        port = granted[0] || await navigator.serial.requestPort(); // no filters → show all
        log('port selected');
        await openPortIfNeeded(port);

        transport = new TransportCtor(port);
        if (transport.connect) {
          try { await transport.connect(115200); } catch(e){ log('transport.connect note: ' + e); }
        }

        loader = new ESPLoaderCtor({ transport, baudrate: 115200, terminal: term });

        log('connecting to bootloader… (hold BOOT if required)');
        await loader.connect('default_reset', 7, true);
        log('connected. chip: ' + (await loader.chipName()));

        await withStubBaud(921600);

        connected = true;
        disconnectBtn.disabled = false;
        flashBtn.disabled = false;
        log('✅ ready to flash');
      } catch (e) {
        log('❌ connect failed: ' + e);
        await safeCloseAll('connect failed');
      } finally {
        connecting = false;
        if (!connected) connectBtn.disabled = false;
      }
    });

    disconnectBtn.addEventListener('click', async ()=>{ await safeCloseAll('user disconnect'); });

    flashBtn.addEventListener('click', async () => {
      if (!connected) return log('not connected.');
      const file = fwInput.files?.[0]; if (!file) return log('pick a .bin first.');
      const buf = new Uint8Array(await file.arrayBuffer());
      const FACTORY = 0x20000, OTA1 = 0x1C0000;

      try {
        setProgress(0);
        log(`--- flashing factory @ 0x${FACTORY.toString(16)} ---`);
        await flashOnce(buf, FACTORY, (i,n)=>setProgress((i/n)*50));
        await verifyMd5(FACTORY, buf.length);

        log(`--- flashing ota_1 @ 0x${OTA1.toString(16)} ---`);
        await flashOnce(buf, OTA1, (i,n)=>setProgress(50+(i/n)*50));
        await verifyMd5(OTA1, buf.length);

        await loader.after('hard_reset');
        setProgress(100);
        log('✅ done. device reset.');
      } catch (e) {
        log('❌ flash failed: ' + e);
      }
    });

    // Release port on page unload
    addEventListener('beforeunload', async ()=>{ await safeCloseAll('unload'); });
  </script>
</body>
</html>


