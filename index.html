<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>ESP Flasher (Factory + OTA_1)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; margin: 20px; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; margin-bottom:10px; }
    button { padding:8px 12px; }
    #log { white-space:pre-wrap; background:#111; color:#0f0; padding:10px; border-radius:6px; min-height:200px; max-height:50vh; overflow:auto; }
    #progress { width:320px; height:12px; background:#eee; border-radius:6px; overflow:hidden; }
    #bar { height:100%; width:0%; background:#3b82f6; transition:width .1s linear; }
    .muted { color:#666; }
  </style>
</head>
<body>
  <h1>ESP Flasher (Factory + OTA_1)</h1>

  <div class="row">
    <button id="connect" disabled>üîå Connect</button>
    <button id="disconnect" disabled>üîí Disconnect</button>
    <input type="file" id="fw" accept=".bin" />
    <button id="flash" disabled>‚ö° Flash both</button>
  </div>

  <div class="row">
    <div id="progress"><div id="bar"></div></div>
    <span id="pct">0%</span>
  </div>

  <div class="muted">Offsets: Factory = <code>0x20000</code>, OTA_1 = <code>0x1C0000</code></div>

  <pre id="log"></pre>

  <script type="module">
    // ---- UI helpers ----
    const $ = (s)=>document.querySelector(s);
    const logEl = $('#log'), bar = $('#bar'), pct = $('#pct');
    const log = (m="") => { logEl.textContent += m + "\\n"; logEl.scrollTop = logEl.scrollHeight; };
    const setProgress = (n) => { const v = Math.max(0, Math.min(100, n|0)); bar.style.width = v + '%'; pct.textContent = v + '%'; };

    // ---- Load ESPLoader with fallback (ESM -> UMD) ----
    async function loadESPLoader() {
      // Try clean ESM via esm.sh (resolves "pako" etc. for the browser)
      try {
        const mod = await import('https://esm.sh/esptool-js@0.5.7');
        if (mod?.ESPLoader) { log('‚úÖ ESPLoader (ESM) loaded.'); return mod.ESPLoader; }
      } catch (e) {
        log('‚ÑπÔ∏è ESM import failed; falling back to UMD‚Ä¶ (' + e + ')');
      }

      // Fallback: UMD bundle (adds a global)
      await new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = 'https://unpkg.com/esptool-js@0.5.7/bundle.js';
        s.onload = resolve;
        s.onerror = () => reject(new Error('Failed to load UMD bundle.js'));
        document.head.appendChild(s);
      });

      // Try the known global shapes
      const ESPL =
        window.ESPLoader ||
        (window.esptoolJs && window.esptoolJs.ESPLoader) ||
        (window.esptool_js && window.esptool_js.ESPLoader) ||
        (window.esptooljs && window.esptooljs.ESPLoader);

      if (!ESPL) throw new Error('UMD loaded but ESPLoader global not found');
      log('‚úÖ ESPLoader (UMD) loaded.');
      return ESPL;
    }

    // ---- Environment gating ----
    if (!window.isSecureContext) log('‚ùå This page must be served over HTTPS (GitHub Pages is fine).');
    if (!('serial' in navigator)) log('‚ùå Web Serial not available. Use Chrome/Edge desktop, not Safari/Firefox/iOS.');
    let ESPLoaderCtor = null;
    try {
      ESPLoaderCtor = await loadESPLoader();
    } catch (e) {
      log('‚ùå Failed to load esptool-js: ' + e);
    }

    // Enable connect only if everything required is present
    if (ESPLoaderCtor && window.isSecureContext && ('serial' in navigator)) {
      $('#connect').disabled = false;
    } else {
      log('‚ÑπÔ∏è Connect disabled due to missing prerequisites.');
    }

    // ---- Flasher logic ----
    let port = null, loader = null, connected = false;

    async function withStubBaud(targetBaud = 921600) {
      await loader.runStub();
      try { await loader.changeBaud(targetBaud); log('Baud -> ' + targetBaud); }
      catch (e) { log('Baud change failed: ' + e); }
    }

    async function flashOnce(bytes, offset, onBlock) {
      const total = bytes.length;
      const blockSize = loader.FLASH_WRITE_SIZE || 0x400;
      const blocks = await loader.flashDeflBegin(total, total, offset);
      for (let i = 0; i < blocks; i++) {
        const s = i * blockSize, e = Math.min(s + blockSize, total);
        await loader.flashDeflBlock(bytes.subarray(s, e), i, 5000);
        onBlock?.(i + 1, blocks);
      }
      await loader.flashDeflFinish(false);
    }

    async function verifyMd5(offset, length) {
      const md5 = await loader.flashMd5sum(offset, length);
      log(`MD5 @ 0x${offset.toString(16)} = ${md5}`);
    }

    $('#connect').onclick = async () => {
      try {
        log('Connect clicked.');
        // Make sure site permission is allowed for Serial:
        // Chrome: site settings ‚Üí Additional permissions ‚Üí Serial ports ‚Üí Allow
        port = await navigator.serial.requestPort();
        log('Port selected.');
        await port.open({ baudRate: 115200 });
        log('Port opened.');

        loader = new ESPLoaderCtor({ transport: { device: port }, baudrate: 115200, terminal: { write: (s)=>log(String(s)) }});
        log('Connecting to bootloader‚Ä¶ (hold BOOT if required)');
        await loader.connect('default_reset', 7, true);
        log('Connected. Chip: ' + (await loader.chipName()));
        await withStubBaud(921600);

        connected = true;
        $('#disconnect').disabled = false;
        $('#flash').disabled = false;
        log('‚úÖ Ready to flash.');
      } catch (e) {
        log('‚ùå Connect failed: ' + e);
        log('Hints: close Arduino/PlatformIO/serial terminals; check Chrome site permission; try another USB cable/port.');
      }
    };

    $('#disconnect').onclick = async () => {
      try { if (loader) await loader.after('no_reset'); if (port) await port.close(); } catch {}
      connected = false;
      $('#disconnect').disabled = true;
      $('#flash').disabled = true;
      log('Disconnected.');
    };

    $('#flash').onclick = async () => {
      if (!connected) return log('Not connected.');
      const file = $('#fw').files?.[0];
      if (!file) return log('Pick a .bin first.');

      const FACTORY = 0x20000;
      const OTA1    = 0x1C0000;
      const buf = new Uint8Array(await file.arrayBuffer());

      try {
        setProgress(0);
        log(`--- Flashing Factory @ 0x${FACTORY.toString(16)} ---`);
        await flashOnce(buf, FACTORY, (i,n)=>setProgress((i/n)*50));
        await verifyMd5(FACTORY, buf.length);

        log(`--- Flashing OTA_1 @ 0x${OTA1.toString(16)} ---`);
        await flashOnce(buf, OTA1, (i,n)=>setProgress(50+(i/n)*50));
        await verifyMd5(OTA1, buf.length);

        await loader.after('hard_reset');
        setProgress(100);
        log('‚úÖ Done. Device reset.');
      } catch (e) {
        log('‚ùå Flash failed: ' + e);
      }
    };
  </script>
</body>
</html>

